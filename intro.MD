## Цель книги
Цель этой книги — представить несколько классических паттернов разработки и показать, как они
поддерживают разработку через тестирование (TDD), предметно-ориентированное проектирование (DDD) 
и событийно-управляемые службы. Мы надеемся, что она послужит ориентиром для реализации этих паттернов 
на Python и подтолкнет программистов к дальнейшему изучению этой области.

## TDD, DDD и событийно-управляемая архитектура
1. Разработка через тестирование (test-driven development, TDD) помогает писать правильный код, делать 
рефакторинг или добавлять новые возможности, не опасаясь регрессии. Но иногда бывает трудно
использовать тесты по максимуму: как сделать так, чтобы они выполнялись как можно быстрее? Так, 
чтобы мы могли увеличить покрытие и получить больше информации от быстрых юнит-тестов, свободных
от зависимостей, при этом уменьшив число более медленных нестабильных сквозных тестов?
2. Предметно-ориентирование проектирование (domain-driven design,
DDD) предлагает нам сосредоточить усилия на создании модели
хорошей предметной области. Но как освободить модели от инфраструктурной функциональности, чтобы они не 
становились все менее пригодными для внесения изменений?
3. Слабосвязанные (микро)сервисы, интегрированные посредством
сообщений (иногда их называют реактивными микросервисами), являются хорошо зарекомендовавшим себя методом при решении задач,
связанных с управлением сложностью в многочисленных приложениях или предметных областях бизнеса. Но не всегда очевидно, как
вписать их в инструменты мира Python — Flask, Django, Celery и т. д.

## Инкапсуляции и абстракции
Инкапсуляция и абстракция — это то, к чему интуитивно стремятся все программисты, 
даже если явно не говорят об этом. Давайте рассмотрим эти концепции подробнее, 
поскольку они проходят красной нитью через всю книгу.

Термин инкапсуляция охватывает две тесно связанные идеи: упрощение
поведения и сокрытие данных. В нашем случае мы будем иметь в виду
первое. Мы инкапсулируем поведение, определяя задачу, которую необходимо выполнить в коде, и передавая 
эту задачу хорошо определенному объекту или функции. Мы называем этот объект или функцию абстракцией.
Взгляните на следующие два фрагмента кода:
```python
# Выполнить поиск с помощью urllib
import json
from urllib.request import urlopen
from urllib.parse import urlencode

params = dict(q='Sausages', format='json')
handle = urlopen('http://api.duckduckgo.com' + '?' + urlencode(params))
raw_text = handle.read().decode('utf8')
parsed = json.loads(raw_text)
results = parsed['RelatedTopics']

for r in results:
    if 'Text' in r:
        print(r['FirstURL'] + ' - ' + r['Text'])
```

```python
# Выполнить поиск с помощью requests
import requests
params = dict(q='Sausages', format='json')
parsed = requests.get('http://api.duckduckgo.com/', params=params).json()
results = parsed['RelatedTopics']
for r in results:
    if 'Text' in r:
        print(r['FirstURL'] + ' - ' + r['Text'])
```
Оба листинга делают одно и то же: отправляют значения, закодированные
в форме, на URL-адрес, чтобы воспользоваться API поисковой машины. Но
второй код воспринимается легче, потому что работает на более высоком
уровне абстракции.

Мы можем пойти еще дальше, определив и назвав задачу, которую должен
выполнять код. Чтобы сделать ее более явной, мы используем еще более
высокоуровневую абстракцию.
```python
# Выполнить поиск с помощью модуля duckduckgo
import duckduckgo
for r in duckduckgo.query('Sausages').results:
    print(r.url + ' - ' + r.text)
```
